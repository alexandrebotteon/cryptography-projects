# encrypt func
# input <message> from the user
# encode the string to ASCII values
# encoding the ASCII message using <public_key> and <product_of_prime_numbers>
# and encode all the characters in <ascii_message> as 64-byte strings
# compress the message using <zlib> library
# encode <compressed_cipher_text> into Base64 using the <base64> library
# return <cipher_text>


# decrypt func
# input <message> from the user
# decode <message> using Base64
# decompress the <decoded_message>
# create a list of blocks containing 64 bytes
# these 64 bytes were used to encode the message in <encrypt()> function
# decode all the blocks from <blocks_list> into a list of ASCII characters
# decrypt <ascii_message_list> using the <private_key> and <product_of_prime_numbers>
# print <decrypted_message>


# verifying the decrypted message func
# the decrypted message must have a maximum of 128 characters
# if it has more than that, the code will ask for another message
# until it has the correct number of 128 characters


# verifying the main menu inputs func
# if 'encrypt' is selected, the code will verify all the inputs, if they are integers or strings
# using <.isnumeric()> to check if the string is a numerical
# return the <e> and <n> values as integers


# verifying the main menu inputs func
# if 'decrypt' is selected, the code will verify all the inputs, if they are integers or strings
# using <.isnumeric()> to check if the string is a numerical
# return <d> and <n> values as integers


# generating prime numbers func
# generate 'random' prime numbers with 256 bits (2⁸ bits) or 32 bytes (2⁵ bytes)
# where p is not equal to q


# generating n and m func
# calculate the product of our prime numbers (n)
# calculate totient (m) -> Φ(n) <phi of n>


# generating a public key func
# start with 65537 which is a Fernet prime (2¹⁶ + 1 -> 10000000000000001 in binary)
# using this number provides good security against brute force attacks directly
# use 'e' for 'encrypt' -> public key to encrypt data
# <e> must be between 1 and Φ(n) -> 1 < e < Φ(n)
# and gcd between Φ(n) and <e> must be equal 1 -> gcd(Φ(n), e) == 1


# generating a private key func
# <d> is the product of <d> and <e> divided by Φ(n)
# and the result must have a remainder of 1 -> (d * e) % Φ(n) == 1
# use 'd' for 'decrypt' -> private key to decrypt data
# using pow(public_key, -1, Φ(n)) to find <d> -> d = pow(e, -1, m)
# this is the modular inverse algorithm to find <d>


# main menu func
# creating a interactive menu for the users
# input which option you choose
# use <match-case> statement to verify the <option> variable
# define which <case> you choose
# and execute the code inside it


# main func
# executes when the file is directly executed and starts running
# all the funcs to generate the <cipher_text> and <decrypted_message>


# use this conditional to verify if the file is directly executed
# just one best practice